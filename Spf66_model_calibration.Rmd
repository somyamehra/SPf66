---
title: "SPf66 model calibration"
author: "Somya Mehra"
date: "2023-11-20"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
library(dplyr)
library(tidyr)
library(readr)
library(parallel)
library(lubridate)
library(survival)
library(ggplot2)
library(cowplot)
library(ggfortify)
library(GGally)
library(knitr)
library(kableExtra)
library(MatchIt)
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, fig.align = 'center')

library(extrafont)
font_import() # takes a few minutes
loadfonts(device="postscript")

library(showtext)
font_add(family = "Arial", regular = "Arial.ttf") ## here is the path to the font to add.
showtext.auto()
```

## Data input

```{r data_input}
if (!dir.exists("Spf66_calibration")) dir.create("Spf66_calibration")
if (!dir.exists("Metrics_of_interest")) dir.create("Metrics_of_interest")

RUN_ALL <- FALSE # flag whether or not to re-run fitting

# source code for model fitting
source("Model_calibration_code/clin_inf_likelihood_helper_func.R")
source("Model_calibration_code/Metropolis_Hastings_fit.R")
source("Model_calibration_code/simulate_clinical_recurrences.R")

# source code for metrics of epidemiological interest
source("Metrics_of_interest_code/metrics_under_stationary_hyp_reservoir.R")
source("Metrics_of_interest_code/classify_relapses.R")
source("Metrics_of_interest_code/relapses_per_bite.R")

# pre-processed data from SPf66 cohort for model fitting
patient_metadata <- read_rds("Spf66_data_cleaned/patient_metadata.rds")
inf_states_by_VIN <- read_rds("Spf66_data_processed/discretised_infection_matrix.rds")
SEASONALITY <- read_rds("Spf66_data_processed/seasonality_vector.rds") # inferred from Pf

N_COHORT <- nrow(patient_metadata)
keep_VIN <- as.character(patient_metadata$VIN)

# discretisation into uniform windows 
START_DATE <- as.Date("1993-10-01")
END_DATE <- as.Date("1995-07-15")
STUDY_DURATION <- as.numeric(difftime(END_DATE, START_DATE, unit="days"))
TIME_STEP <- 10
N_OBS <- STUDY_DURATION%/%10
SHIFT_WINDOW <- 20 # estimate Pv FOI separately before and after this window
YEAR_IN_TIMESTEP <- 365%/%TIME_STEP
THRESHOLD_AGE <- 2*YEAR_IN_TIMESTEP # possible stratification in FORI above/below this age

# fixed covariates
PREL_BASELINE <- 0.4 # based on in vivo experiments for Chesson strain
N_AGES <- patient_metadata[names(inf_states_by_VIN), "AGE"]*YEAR_IN_TIMESTEP # in units of TIME_STEP
names(N_AGES) <- names(inf_states_by_VIN)

# number of chains and iterations for MCMC (nested parallelisation over chains)
N_CHAINS <- 4
N_ITER <- 100000
BURNIN_PROP <- 0.2
N_CORES_PER_CHAIN <- 8

# parameters for Metropolis-Hastings proposal
LAMBDA_PROP_SD <- 0.02/365
NU_PROP_SD <- 0.2
ETA_PROP_SD <- 1/2000
LOGIT_RHO_PROP_SD <- 0.05
LOG_GAMMA_PROP_SD <- 0.05

# hyperparameters for informative priors
LOG_GAMMA_PRIOR_SD <- 0.6
LOGIT_RHO_PRIOR_SD <- 0.7

# parameters for posterior predictive data
N_POSTERIOR_PREDICTIVE_DATASETS <- 2000
PROP_MASKED <- 0.5
PROPHYLAXIS_WINDOW <- 1
BUNCHING_WINDOW <- 2

# observed data for posterior predictive checking
masking_periods <- read_rds("Spf66_data_processed/masking_periods.rds")
observed_incidence_by_indiv <- read_rds("Spf66_data_processed/incidence_by_individual.rds") 
observed_incidence_by_window <- read_rds("Spf66_data_processed/incidence_by_window.rds")
malaria_consultations_reconciled <- read_rds("Spf66_data_processed/malaria_consultations_reconciled.rds")

# formatting
POSTERIOR_COL <- "#cf7940"
OBSERVED_COL <- "#4878b8"
```

## Inference with Metropolis-Hastings algorithm

**Baseline model**: assumes geometrically-distributed sporozoite inocula, with the ratio of hypnozoites to immediately-developing forms informed by *in vivo* estimates for the Chesson strain and no age-stratification in the force of inoculation

```{r metropolis_hastings}
if (RUN_ALL || !file.exists("Spf66_calibration/MCMC_results_main.rds")) {
  set.seed("28091907")
  
  # rescale LAMBDA2 to be the mean FOI in the second stage of the study
  MCMC_results <- Metropolis_Hastings(inf_states_by_VIN, N_AGES, PREL_BASELINE, N_OBS, TIME_STEP,
                                    SEASONALITY, SHIFT_WINDOW, THRESHOLD_AGE, 1,
                                    N_CHAIN, N_ITER, N_CORES_PER_CHAIN,
                                    LAMBDA_PROP_SD, NU_PROP_SD, ETA_PROP_SD,
                                    LOGIT_RHO_PROP_SD, LOG_GAMMA_PROP_SD,
                                    LOG_GAMMA_PRIOR_SD, LOGIT_RHO_PRIOR_SD) %>%
      mutate(LAMBDA2=LAMBDA2*mean(tail(SEASONALITY, N_OBS)[(SHIFT_WINDOW+1):N_OBS]))
  
  write_rds(MCMC_results, "Spf66_calibration/MCMC_results_main.rds")

} else {
  
  MCMC_results <- read_rds("Spf66_calibration/MCMC_results_main.rds")
    
}

MCMC_posterior <- MCMC_results %>% subset(ITER>BURNIN_PROP*N_ITER) %>% mutate(CHAIN=as.character(CHAIN))

```

### Convergence diagnostics
```{r convergence, fig.height=7, fig.width=10, echo=FALSE}
param_labels <- c("LAMBDA1", "LAMBDA2", "NU", "ETA", "LOGIT_RHO", "LOG_GAMMA")

Gelman_Rubin_diagnostic <- 
  calculate_Gelman_Rubin(MCMC_results, N_ITER, BURNIN_PROP*N_ITER, N_CHAINS, param_labels)

Gelman_Rubin_diagnostic <- 
  data.frame(variable=factor(names(Gelman_Rubin_diagnostic), 
                             levels=param_labels),
             R=paste0("Gelman-Rubin diagnostic: R=", 
                      round(Gelman_Rubin_diagnostic, 4), collapse=NULL))

MCMC_trace_melted <- MCMC_results %>% 
  dplyr::select(-LOG_LIK) %>% reshape2::melt(id=c("CHAIN", "ITER")) %>%
  mutate(variable=factor(variable, levels=param_labels))

trace_plot_main <- ggplot() + 
       geom_line(data=MCMC_trace_melted, 
                 aes(x=ITER, y=value, color=as.character(CHAIN)), lwd=0.2) +
       geom_label(data=Gelman_Rubin_diagnostic, 
                  aes(x=N_ITER, y=Inf, label=R, hjust=1, vjust=1)) +
       annotate("rect", xmin=0, xmax=BURNIN_PROP*N_ITER, ymin=-Inf, ymax=Inf, fill="grey", alpha=0.4) +
       facet_grid(rows=vars(variable), scale="free_y") + 
       xlab("Iteration") + ylab("") + 
       theme_bw() + theme(legend.position = "none")

show(trace_plot_main)

png("Spf66_calibration/trace_plots_main.png", height=7, width=10, units="in", res=400)
show(trace_plot_main)
invisible(dev.off())
```

### Pairwise posterior plots
```{r pairwise_posterior_plots, fig.height=12, fig.width=12, echo=FALSE}
MCMC_prior <- data.frame(LOG_GAMMA=rnorm(50000, sd=LOG_GAMMA_PRIOR_SD), 
                         LOGIT_RHO=rnorm(50000, sd=LOGIT_RHO_PRIOR_SD))

pairwise_posterior <- MCMC_posterior %>%
  dplyr::select(LAMBDA1, LAMBDA2, NU, ETA, LOGIT_RHO, LOG_GAMMA) %>% 
  ggpairs(diag="blank", lower = list(continuous = wrap("points", alpha = 0.0025, size=0.01))) +
  theme_bw()

pairwise_posterior[1, 1] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=LAMBDA1, color=CHAIN)) + 
  theme_bw() + theme(legend.position = "none")

pairwise_posterior[2, 2] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=LAMBDA2, color=CHAIN)) + 
  theme_bw() + theme(legend.position = "none")

pairwise_posterior[3, 3] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=NU, color=CHAIN)) + 
  theme_bw() + theme(legend.position = "none")

pairwise_posterior[4, 4] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=ETA, color=CHAIN)) + 
  theme_bw() + theme(legend.position = "none")

pairwise_posterior[5, 5] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=LOGIT_RHO, color=CHAIN)) + 
  geom_density(data=MCMC_prior, aes(x=LOGIT_RHO), fill="black", alpha=0.15, lwd=0.1) + 
  theme_bw() + theme(legend.position = "none")

pairwise_posterior[6, 6] <- ggplot() +
  geom_density(data=MCMC_posterior, aes(x=LOG_GAMMA, color=CHAIN)) +
  geom_density(data=MCMC_prior, aes(x=LOG_GAMMA), fill="black", alpha=0.15, lwd=0.1) + 
  theme_bw() + theme(legend.position = "none")


show(pairwise_posterior)

png("Spf66_calibration/pairwise_posterior_plots_main.png",
    height=12, width=12, units="in", res=400)
show(pairwise_posterior)
invisible(dev.off())
```

### Summary of posterior estimates
Below, we report posterior median estimates and 95% confidence intervals for various quantites of epidemiological interest.

```{r posterior_summary_table, echo=FALSE}
MCMC_posterior %>% 
  transmute(`Average duration of hypnozoite carriage (days)`=1/ETA,
            `Half-life of a hypnozoite batch (days)`=log(2)/ETA,
            `Prob of activation in 2 week window`=1-exp(-14*ETA),
            `Prob of activation in 4 week window`=1-exp(-28*ETA),
            `Prob of activation in 12 week window`=1-exp(-84*ETA),
            `Prob of activation in 24 week window`=1-exp(-168*ETA),
            `Average sporozoite batch size`=NU,
            `Average hypnozoite batch size`=NU*PREL_BASELINE,
            `Prob of primary infection per bite`=1-1/(1+NU*(1-PREL_BASELINE)),
            `No primary but at least one relapse per bite`=1/(1+NU*(1-PREL_BASELINE)) - 1/(1+NU),
            `Prob at least 2 recurrences per bite`=PREL_BASELINE*NU*(2-PREL_BASELINE+NU)/
              ((1+NU)*(1+PREL_BASELINE*NU)),
            `Relapse:primary ratio per bite`=NU*PREL_BASELINE+PREL_BASELINE/(1-PREL_BASELINE),
            `Prob relapse within 2 weeks of bite`=1-1/(1+NU*PREL_BASELINE*(1-exp(-14*ETA))),
            `Average force of inoculation in first stage of study (yearly)`=LAMBDA1*365,
            `Average force of inoculation in second stage of study (yearly)`=LAMBDA2*365,
            `Average force of prim inf in first stage of study (yearly)`=LAMBDA1*(1-1/(1+NU*(1-PREL_BASELINE)))*365,
            `Average force of prim inf in second stage of study (yearly)`=LAMBDA2*(1-1/(1+NU*(1-PREL_BASELINE)))*365) %>%
  reshape2::melt() %>% group_by(variable) %>% 
  summarise(median=median(value), LCI=quantile(value, 0.025), UCI=quantile(value, 0.975)) %>%
  kable %>% kable_styling


```

```{r pclin_plot, fig.height=2.8, fig.width=5, echo=FALSE}
N_CURVES <- 400

AGES <- sort(unique(patient_metadata$AGE))
MAX_AGE <- max(AGES)
MIN_AGE <- min(AGES)

pclin_CI <- sapply(AGES, function(a) {
  quantile(calculate_pclin(a, MCMC_posterior$LOGIT_RHO, MCMC_posterior$LOG_GAMMA, 
                           MIN_AGE, MAX_AGE), c(0.025, 0.5, 0.975))}) %>% 
  t %>% as.data.frame %>% mutate(AGE=AGES)

MY_AGES <- seq(MIN_AGE, MAX_AGE, (MAX_AGE-MIN_AGE)/200)
posterior_subset <- MCMC_results[sample(1:nrow(MCMC_results), N_CURVES, replace = T),]

pclin_curves <- sapply(MY_AGES, function(a) {
  calculate_pclin(a, posterior_subset$LOGIT_RHO, posterior_subset$LOG_GAMMA,
                  MIN_AGE, MAX_AGE)}) %>% t %>%
  as.data.frame %>% mutate(AGE=MY_AGES) %>%
  reshape2::melt(id="AGE")

pclin_posterior_plot <- ggplot() + 
  geom_line(data=pclin_curves, aes(x=AGE, y=value, group=variable), 
            lwd=0.01, alpha=0.1, col=POSTERIOR_COL) +
  geom_errorbar(data=pclin_CI, aes(x=AGE, ymin=`2.5%`, ymax=`97.5%`), lwd=0.5, width=0.4) +
  geom_point(data=pclin_CI, aes(x=AGE, y=`50%`), fill=POSTERIOR_COL, size=2.5, pch=21) + 
  coord_cartesian(ylim=c(0, NA)) +
  xlab("Age at enrolment (years)") + 
  ylab("Probability blood-stage\ninfection is symptomatic") +
  ggtitle("Age-dependent antidisease immunity") +
  theme_light() + theme(plot.title = element_text(hjust=0.5, face="bold"))

pdf("Spf66_calibration/marginal_posterior_pclin.pdf", height=2.8, width=5)
show(pclin_posterior_plot)
invisible(dev.off())

```

```{r force_prim_inf_plot, fig.height=3.5, fig.width=12, out.width="100%", echo=FALSE}
prim_inf_scaling <- MCMC_posterior %>% 
  transmute(RATE_1=LAMBDA1*(1-1/(1+NU*(1-PREL_BASELINE))),
            RATE_2=LAMBDA2*(1-1/(1+NU*(1-PREL_BASELINE)))/
              mean(tail(SEASONALITY, N_OBS)[(SHIFT_WINDOW+1):N_OBS]))

prim_inf <- data.frame(START=START_DATE+days(TIME_STEP*(0:(N_OBS-1))),
                       seasonality=tail(SEASONALITY, N_OBS)) %>%
  mutate(END=START+days(TIME_STEP),
         MEDIAN=c(rep(median(prim_inf_scaling$RATE_1), SHIFT_WINDOW),
                  rep(median(prim_inf_scaling$RATE_2), N_OBS-SHIFT_WINDOW))*seasonality,
         LCI=c(rep(quantile(prim_inf_scaling$RATE_1, 0.025), SHIFT_WINDOW),
               rep(quantile(prim_inf_scaling$RATE_2, 0.025), N_OBS-SHIFT_WINDOW))*seasonality,
         UCI=c(rep(quantile(prim_inf_scaling$RATE_1, 0.975), SHIFT_WINDOW),
               rep(quantile(prim_inf_scaling$RATE_2, 0.975), N_OBS-SHIFT_WINDOW))*seasonality)

force_prim_inf_posterior_plot <- ggplot(prim_inf) + 
  geom_segment(aes(x=START, xend=END, y=MEDIAN*30, yend=MEDIAN*30), col=POSTERIOR_COL, lwd=0.9) + 
  geom_segment(aes(x=START, xend=START, yend=MEDIAN*30, y=lag(MEDIAN*30)), lty=3, lwd=0.5, col=POSTERIOR_COL) + 
  geom_rect(aes(xmin=START, xmax=END, ymin=LCI*30, ymax=UCI*30), alpha=0.2, fill=POSTERIOR_COL) +
  coord_cartesian(ylim=c(0, NA)) +
  xlab("Date") + 
  ylab("Force of primary blood-stage\ninfection (per month)") +
  ggtitle("Force of primary blood-stage infection") +
  theme_light() + theme(plot.title = element_text(hjust=0.5, face="bold"))

pdf("Spf66_calibration/marginal_posterior_force_prim_inf.pdf", height=2.8, width=5)
show(force_prim_inf_posterior_plot)
invisible(dev.off())

show(plot_grid(pclin_posterior_plot, force_prim_inf_posterior_plot, 
               nrow=1, align="vh", axis="tblr"))

```

```{r posterior_median_estimates}
ETA_POSTERIOR=median(MCMC_posterior$ETA)
NU_POSTERIOR=median(MCMC_posterior$NU)

FORI_POSTERIOR <- 
  time_dependent_fori(median(MCMC_posterior$LAMBDA1), 
                      median(MCMC_posterior$LAMBDA2)/
                        mean(tail(SEASONALITY, N_OBS)[(SHIFT_WINDOW+1):N_OBS]),
                      SHIFT_WINDOW, SEASONALITY)

AGES <- sort(unique(patient_metadata$AGE))
PCLIN_POSTERIOR <- sapply(AGES, function(a) {
  median(calculate_pclin(a, MCMC_posterior$LOGIT_RHO, MCMC_posterior$LOG_GAMMA, 
                           min(AGES), max(AGES)))})
names(PCLIN_POSTERIOR) <- AGES
```

## Posterior predictive checking

We generate posterior predictive data under the model by sampling parameter combinations uniformly at random (without replacement) from the joint posterior. For comparability, we retain the age structure of the SPf66 cohort in addition to patterns of left/right-censoring and documented absences from the camp. The effects of post-exposure prophylaxis due to the treatment of symptomatic falciparum malaria is **not** accounted for. 

```{r masking_matrix}
MASKING_MATRIX <- masking_periods[["exc_prophylaxis"]] %>% 
  transmute(VIN=factor(VIN, levels=keep_VIN),
            window_start=START%/%TIME_STEP+1, window_end=END%/%TIME_STEP+1, 
            prop_window_start=1-(START%%TIME_STEP)/TIME_STEP, 
            prop_window_end=(END%%TIME_STEP)/TIME_STEP) %>%
  split(f=.$VIN) %>%
  sapply(function(masking_windows) {
    masking_windows <- masking_windows %>% dplyr::select(-VIN)
    
    inf_state <- rep(1, N_OBS)
    if (nrow(masking_windows)<1) return(inf_state)
    
    # fully masked windows
    fully_masked <- masking_windows %>% subset(window_end-window_start>1) %>% 
      apply(1, function(x) (x[1]+1):(x[2]-1)) 
    if (is.list(fully_masked)) fully_masked <- do.call(c, fully_masked)
    inf_state[fully_masked] <- NA
    
    # calculate proportion of each window that is masked due to prophylaxis or absence
    proportion_masked <- rep(0, N_OBS)
    proportion_masked[masking_windows$window_start] <- 
      proportion_masked[masking_windows$window_start] + masking_windows$prop_window_start
    proportion_masked[masking_windows$window_end] <- 
      proportion_masked[masking_windows$window_end] + masking_windows$prop_window_end
    inf_state[which(proportion_masked>PROP_MASKED)] <- NA
    return(inf_state)}) %>% t

write_rds(MASKING_MATRIX, "Spf66_data_processed/discretised_masking_matrix.rds")
```

Each simulated symptomatic episode is modeled to be treated with a long-lived antimalarial that gives rise to prophylactic masking for `r PROPHYLAXIS_WINDOW`, and a potential bunching effect for the subsequent `r BUNCHING_WINDOW` windows (where each window spans `r TIME_STEP` days).

```{r simulate_data}
set.seed("15051907")
  
posterior_draws <- MCMC_posterior[sample(1:nrow(MCMC_posterior), N_POSTERIOR_PREDICTIVE_DATASETS),]

MIN_AGE <- min(N_AGES)
MAX_AGE <- max(N_AGES)

posterior_predictive_cohorts <- lapply(1:N_POSTERIOR_PREDICTIVE_DATASETS, function(i) {
  simulate_dataset(time_dependent_fori(posterior_draws[i, "LAMBDA1"], 
                                        posterior_draws[i, "LAMBDA2"]/mean(tail(SEASONALITY, N_OBS)[(SHIFT_WINDOW+1):N_OBS]), 
                                        SHIFT_WINDOW, SEASONALITY),
                    TIME_STEP, N_AGES, N_OBS, posterior_draws[i, "NU"], 1, 
                    posterior_draws[i, "ETA"], PREL_BASELINE, PROPHYLAXIS_WINDOW, BUNCHING_WINDOW,
                    calculate_pclin(N_AGES, posterior_draws[i, "LOGIT_RHO"], 
                                   posterior_draws[i, "LOG_GAMMA"], MIN_AGE, MAX_AGE),
                    MASKING_MATRIX, 1, MIN_AGE)})

```

To evaluate model fit, we perform posterior predictive checks for age structure in the incidence of symptomatic vivax malaria, as well as time variation in incidence of symptomatic vivax malaria over the course of the study.

### Age structure in symptomatic malaria episodes
We calculate the incidence rate, stratified by age at enrolment, as the quotient of the total number of symptomatic malaria episodes recorded for an age group and the cumulative duration of clinical follow-up for the age group.

```{r age_structure_incidence_rate}
incidence_rate <- list()

incidence_rate[["Posterior predicted"]] <- sapply(posterior_predictive_cohorts, function(x) {
  split(x, patient_metadata[rownames(x), "AGE"]) %>% 
    sapply(function(y) sum(y==1, na.rm = TRUE)/sum(!is.na(y))*365%/%TIME_STEP)}) %>% 
  apply(1, function(x) quantile(x, c(0.025, 0.5, 0.975))) %>% 
  t %>% as.data.frame %>% mutate(AGE=as.numeric(rownames(.)))


N_BOOTSTRAP_REPLICATES <- 2000
observed_incidence_bootstrap <- lapply(1:N_BOOTSTRAP_REPLICATES, function(i) {
  observed_incidence_by_indiv[sample(1:N_COHORT, N_COHORT, replace=T),]})

incidence_rate[["Observed"]] <- lapply(observed_incidence_bootstrap, function(x) {
  x %>% group_by(AGE) %>% summarise(mean_incidence=sum(N_Pv)/sum(Followup_Pv))}) %>% 
  bind_rows(.id="iter") %>%
  group_by(AGE) %>% 
  summarise(`2.5%`=quantile(mean_incidence, 0.025),
            `50%`=quantile(mean_incidence, 0.5),
            `97.5%`=quantile(mean_incidence, 0.975))
```

```{r age_structure_incidence_rate_plot, echo=FALSE, fig.width=7, fig.height=4, out.width="60%"}
incidence_rate_plot <- 
  ggplot(bind_rows(incidence_rate, .id="source"), 
         aes(x=AGE, y=`50%`, ymin=`2.5%`, ymax=`97.5%`, group=source, col=source)) +
  geom_errorbar(width = 0.4, position=position_dodge(width=0.5), lwd=0.4) +
  geom_point(position=position_dodge(width=0.5), size=2) +
  geom_smooth(se = FALSE, lwd=0.5) +
  xlab("Age (years)") + ylab("Incidence rate\n(symptomatic vivax episodes per year)") + 
  ggtitle("Aggregated incidence rate of symptomatic vivax malaria") +
  scale_x_continuous(breaks=2:15) +
  scale_color_manual(values=c(OBSERVED_COL, POSTERIOR_COL), name=NULL) +
  #facet_grid(cols=vars(source)) +
  theme_bw() + theme(plot.title = element_text(face="bold", hjust=0.5),
                     strip.text = element_text(size=11),
                     strip.background = element_rect(fill="#f0f0f0"),
                     legend.position = c(0.82, 0.82))

show(incidence_rate_plot)

```

Additionally, we consider empirical cumulative distribution functions for the incidence by individual, stratified by age group.

```{r age_structure_indiv_incidence}
age_counts <- patient_metadata %>% group_by(AGE) %>% summarise(count=n()) %>%
  mutate(count=factor(paste0(AGE, " years old\n(n=", count, ")"),
                      levels=paste0(2:15, " years old\n(n=", count, ")")))

indiv_incidence_simulated <- lapply(posterior_predictive_cohorts, function(x) {
  data.frame(incidence=rowSums(x==1, na.rm=TRUE)/rowSums(!is.na(x))*(365%/%TIME_STEP), 
             AGE=patient_metadata[rownames(x), "AGE"]) %>%
    arrange(AGE, incidence) %>% mutate(index=1:nrow(.))}) %>%
  bind_rows(.id="iter") %>% group_by(AGE, index) %>% 
  summarise(median=median(incidence), LCI=quantile(incidence, 0.025), 
            UCI=quantile(incidence, 0.975)) %>% split(f=.$AGE) %>% 
  lapply(function(x) x %>% mutate(index=seq(1/nrow(.), 1, 1/nrow(.)))) %>% 
  bind_rows %>% merge(age_counts)

```

```{r age_structure_indiv_incidence_plot, echo=FALSE, fig.height=5, fig.width=12, out.width="100%"}

observed_incidence_by_indiv <- merge(observed_incidence_by_indiv, age_counts)

indiv_incidence_plot <- ggplot() +
  geom_line(data=indiv_incidence_simulated,
            aes(x=median, y=index, group=AGE, color="Posterior predicted"), lwd=0.7) +
  geom_ribbon(data=indiv_incidence_simulated,
              aes(xmin=LCI, xmax=UCI, y=index, group=AGE), fill=POSTERIOR_COL, alpha=0.25) +
  geom_line(data=observed_incidence_by_indiv,
            aes(x=Incidence_Pv, group=AGE, color="Observed"), stat="ecdf", lwd=0.7) +
  facet_wrap(vars(count), nrow=2) + 
  scale_color_manual(values=c(OBSERVED_COL, POSTERIOR_COL), name=NULL) +
  coord_cartesian(xlim=c(0, 6)) + 
  scale_x_continuous(expand=c(0, 0)) + scale_y_continuous(expand=c(0, 0)) + 
  xlab("Total number of symptomatic vivax episodes per year") + 
  ylab("Cumulative distribution function") + 
  ggtitle("Incidence of symptomatic vivax malaria per child") +
  theme_bw() + theme(plot.title = element_text(face="bold", hjust=0.5),
                     strip.text = element_text(size=11),
                     strip.background = element_rect(fill="#f0f0f0"),
                     legend.position = "bottom",
                     legend.text = element_text(size=10))

show(indiv_incidence_plot)

incidence_rate_plot_mid <- 
  cowplot::plot_grid(NULL, incidence_rate_plot, NULL, nrow=1, 
                     rel_widths=c(1, 3, 1))
age_structure_plots <-
  cowplot::plot_grid(incidence_rate_plot_mid, indiv_incidence_plot, 
                     ncol=1, scale=0.95, labels=c("(A)", "(B)"),
                     rel_heights = c(1, 1.3))

pdf("Spf66_calibration/age_structure_plots.pdf", height=9, width=10.5)
show(age_structure_plots)
invisible(dev.off())

```

### Incidence in windows
We compare the incidence by window for posterior predictive data against the observed incidence of symptomatic vivax malaria (calculated in `r 2*TIME_STEP` day windows, with a moving average across half-windows). 

```{r incidence_by_window}
posterior_predictive_incidence_by_window <- lapply(posterior_predictive_cohorts, function(y) {
  per_window <- colSums(y==1, na.rm = TRUE)/colSums(!is.na(y))
  return(sapply(1:(length(per_window)-1), 
                function(i) mean(c(per_window[i], per_window[i+1]))))}) %>%
  do.call(cbind, .) %>% 
  apply(1, function(x) quantile(x*YEAR_IN_TIMESTEP, c(0.025, 0.5, 0.975))) %>% 
  t %>% as.data.frame %>% 
  mutate(Date=days((1:(N_OBS-1))*TIME_STEP)+START_DATE)
```

```{r incidence_by_window_plot, echo=FALSE, fig.height=4, fig.width=12, out.width="100%"}
observed_incidence_by_window <- observed_incidence_by_window %>% 
  subset(Diagnosis=="Pv") %>% mutate(Date=as.Date(Date))

incidence_by_window_plot <- ggplot() + 
  geom_point(data=posterior_predictive_incidence_by_window,  
             aes(x=Date, y=`50%`/12, col="Posterior predicted"), pch=4, size=2) + 
  geom_errorbar(data=posterior_predictive_incidence_by_window, 
                aes(x=Date, ymin=`2.5%`/12, ymax=`97.5%`/12, col="Posterior predicted"), size=0.3) + 
  geom_point(data=observed_incidence_by_window, aes(x=Date, y=incidence/12, col="Observed"), size=2, pch=15) +
  geom_line(data=observed_incidence_by_window, aes(x=Date, y=incidence/12, col="Observed"), size=0.3) + 
  coord_cartesian(ylim=c(0, NA)) +
  scale_color_manual(name=NULL, values=c(OBSERVED_COL, POSTERIOR_COL)) +
  ylab("Incidence per child per month") + 
  labs(title="Incidence of symptomatic vivax malaria",
       subtitle=paste0("calculated in ", TIME_STEP*2, 
                       " day windows, moving average across half-windows")) + 
  theme_bw() + theme(plot.subtitle = element_text(hjust=0.5),
                     plot.title = element_text(face="bold", hjust=0.5),
                     legend.position = c(0.9, 0.85))

show(incidence_by_window_plot)

pdf("Spf66_calibration/incidence_by_window.pdf", height=4, width=9)
show(incidence_by_window_plot)
invisible(dev.off())
```

## Vivax malaria following falciparum monoinfection
For `r N_POSTERIOR_PREDICTIVE_DATASETS` parameter combinations sampled uniformly at random from the posterior, we derive the likelihood of observing a clinical vivax recurrence in a specified window due to either spontaneous hypnozoite activation or reinfection event. In doing so, we condition on the history of vivax recurrence prior to the baseline falciparum episode for each child; in addition to potential masking in the window due to lapses in clinical follow-up (left- or right-censoring, or a documented absence from the camp) or post-exposure prophylaxis following the treatment of falciparum malaria. Given the resultant likelihood vector, we model the number of falciparum monoinfections followed by vivax within the specified windows to follow a Poisson binomial distribution (i.e. as a sum of independent, but non-identically distributed Bernoulli random variables).


```{r prob_vivax_in_window}
POST_WINDOWS <- 2:8

Pv_treatment_masking <- malaria_consultations_reconciled %>%
  subset(VIVAX==1 & VIVAX_MASKING>0) %>%
  transmute(VIN=factor(VIN, levels=keep_VIN),
            START=RelativeTime%/%TIME_STEP+2,
            END=(TIME_STEP*(RelativeTime%/%TIME_STEP)+TIME_STEP/2+VIVAX_MASKING)%/%TIME_STEP)

FORI_posterior_subset <- mapply(time_dependent_fori, 
                                posterior_draws$LAMBDA1,
                                posterior_draws$LAMBDA2/mean(tail(SEASONALITY, N_OBS)[(SHIFT_WINDOW+1):N_OBS]),
                                SHIFT_WINDOW, list(SEASONALITY), SIMPLIFY = F)

vivax_recur_prob_indiv <- function(my_VIN, WINDOW, POST_WINDOW) {
  inf_states <- inf_states_by_VIN[[my_VIN]]
  
  target_window <- WINDOW+(1:POST_WINDOW)
  target_window <- subset(target_window, target_window<=N_OBS)
  
  # mask any infections after the falciparum episode window
  if (max(target_window)<N_OBS) {
    inf_states[(max(target_window)+1):N_OBS] <- "M"
  }
  
  # unmask prophylaxis due to Pv in the target window
  Pv_after_Pf_masking <- Pv_treatment_masking %>% subset(VIN==my_VIN & START>WINDOW+1)
  Pv_after_Pf_masking <- 
    intersect(do.call(c, mapply(function(i, j) {i:j}, 
                                Pv_after_Pf_masking$START, Pv_after_Pf_masking$END, 
                                SIMPLIFY = FALSE)), target_window)
  if (length(Pv_after_Pf_masking)>0) inf_states[Pv_after_Pf_masking] <- "N"
  
  # generate S vectors before and after baseline Pf
  no_Pv_after_Pf <- masked_after_Pf <- inf_states
  no_Pv_after_Pf[target_window] <- gsub("C|B", "N",  no_Pv_after_Pf[target_window])
  masked_after_Pf[target_window] <- "M"
  
  if (all(inf_states[target_window]=="M")) return(rep(NA, N_POSTERIOR_PREDICTIVE_DATASETS))
  
  Pv_after_Pf_observed <- any(inf_states[target_window]=="C")

  S_vectors_no_Pv_after_Pf <- generate_S_vectors(list(no_Pv_after_Pf))
  S_vectors_masked_after_Pf <- generate_S_vectors(list(masked_after_Pf))
  
  likelihood_no_Pv_after_Pf <- mcmapply(inc_exc_likelihood,
                                        S_vectors_no_Pv_after_Pf[["S_plus"]][1], 
                                        S_vectors_no_Pv_after_Pf[["S_minus"]][1], 
                                        patient_metadata[my_VIN, "AGE"]*YEAR_IN_TIMESTEP,
                                        calculate_pclin(patient_metadata[my_VIN, "AGE"],
                                                        posterior_draws$LOGIT_RHO, 
                                                        posterior_draws$LOG_GAMMA, 
                                                        min(AGES), max(AGES)),
                                        FORI_posterior_subset,
                                        posterior_draws$ETA, posterior_draws$NU,
                                        PREL_BASELINE, N_OBS, TIME_STEP, 1, 1)
  
  likelihood_masked_after_Pf <- mcmapply(inc_exc_likelihood,
                                         S_vectors_masked_after_Pf[["S_plus"]][1],
                                         S_vectors_masked_after_Pf[["S_minus"]][1], 
                                         patient_metadata[my_VIN, "AGE"]*YEAR_IN_TIMESTEP,
                                         calculate_pclin(patient_metadata[my_VIN, "AGE"],
                                                         posterior_draws$LOGIT_RHO,
                                                         posterior_draws$LOG_GAMMA, 
                                                         min(AGES), max(AGES)),
                                         FORI_posterior_subset,
                                         posterior_draws$ETA, posterior_draws$NU,
                                         PREL_BASELINE, N_OBS, TIME_STEP, 1, 1)
  
  return(1-likelihood_no_Pv_after_Pf/likelihood_masked_after_Pf)
}
```

### Confounding due to seasonality
To gauge confounding due to seasonality, we consider the observed vs model-predicted rate of vivax recurrence in fixed windows following various time points in the SPf66 trial.

```{r seasonality_confounding}

vivax_recur_cohort <- function(WINDOW, POST_WINDOW) {
  #print(paste0(WINDOW, ", ", POST_WINDOW))
  prob_per_window <- sapply(as.character(patient_metadata$VIN), 
                            vivax_recur_prob_indiv, WINDOW, POST_WINDOW)
  prob_per_window <- prob_per_window[,colMeans(apply(prob_per_window, 2, is.na))<1]
  
  if (length(prob_per_window)==0 | is.null(dim(prob_per_window))) return(NULL) 

  N_partial_followup <- ncol(prob_per_window)
  N_Pv <- length(unique((malaria_consultations_reconciled %>% 
                           subset(VIVAX==1 & RelativeTime>TIME_STEP*WINDOW &
                                    RelativeTime<TIME_STEP*(WINDOW+POST_WINDOW)))$VIN))
  
  Pv_prop_vals <- seq(0, 1, 1/N_partial_followup)
      
  Pv_prop_cdf <- apply(prob_per_window, 1, function(pp) {
      pp <- subset(pp, pp>0 & pp<1)
      return(poisbinom::ppoisbinom(length(pp)*Pv_prop_vals, pp))})

  Pv_summary <- data.frame(Prop_Pv=Pv_prop_vals, CDF=rowMeans(Pv_prop_cdf),
             WINDOW=WINDOW, POST_WINDOW=POST_WINDOW, observed=FALSE)
  Pv_summary[N_Pv+1, "observed"] <- TRUE
  
  return(Pv_summary)
}

if (RUN_ALL || !file.exists("Spf66_calibration/vivax_recur_cohort_pred.rds")) {
  
  vivax_recur_cohort_pred <- mapply(vivax_recur_cohort, 
                                  rep(seq(0, 55, 5), each=length(POST_WINDOWS)),
                                  rep(POST_WINDOWS, 12), SIMPLIFY = FALSE)
  
  write_rds(vivax_recur_cohort_pred, "Spf66_calibration/vivax_recur_cohort_pred.rds")
  
} else {
  
  vivax_recur_cohort_pred <- read_rds("Spf66_calibration/vivax_recur_cohort_pred.rds")
  
}


vivax_recur_CrI <- 
  data.frame(WINDOW=sapply(vivax_recur_cohort_pred, function(x) x[1, "WINDOW"]),
             POST_WINDOW=sapply(vivax_recur_cohort_pred, function(x) x[1, "POST_WINDOW"])*TIME_STEP,
             LCI=sapply(vivax_recur_cohort_pred, function(x) min(subset(x$Prop_Pv, x$CDF>=0.005))),
             UCI=sapply(vivax_recur_cohort_pred, function(x) min(subset(x$Prop_Pv, x$CDF>=0.995))),
             observed=sapply(vivax_recur_cohort_pred, function(x) subset(x$Prop_Pv, x$observed)[1]),
             pvalue=sapply(vivax_recur_cohort_pred, function(x) subset(x$CDF, x$observed)[1])) %>%
  mutate(BASELINE=paste0(START_DATE+days(TIME_STEP*WINDOW), " (day ", TIME_STEP*WINDOW, ")"))

```

```{r seasonality_confounding_plots, fig.height=6, fig.width=7, echo=FALSE}
seasonality_confounding_plots <- 
  ggplot(vivax_recur_CrI, 
         aes(x=POST_WINDOW, group=BASELINE, color=(observed>LCI & observed<UCI))) +
  geom_errorbar(aes(ymin=LCI, ymax=UCI)) + 
  geom_point(aes(y=observed)) + 
  facet_wrap(vars(BASELINE)) + 
  scale_color_discrete(name="", labels=c("Observed value outside 99% CrI", 
                                         "Observed value within 99% CrI")) + 
  xlab("Follow-up period (days)") + 
  ylab("Proportion of children with a vivax recurence") + 
  ggtitle("Vivax recurrence in fixed periods of follow-up") + 
  theme_bw() + theme(legend.position = "bottom", 
                     plot.title = element_text(hjust=0.5, face="bold"))

show(seasonality_confounding_plots)

pdf("Spf66_calibration/vivax_recurrence_in_windows.pdf", height=6, width=7)
show(seasonality_confounding_plots)
invisible(dev.off())
```

### Vivax after falciparum

Various studies have demonstrated an elevated risk of vivax malaria following febrile falciparum episodes. To mimic the structure of a typical study, we focus on the burden of vivax recurrence in fixed follow-up windows following each symptomatic falciparum monoinfection. We stratify baseline episodes based on treatment with artesunate monotherapy vs artesunate-mefloquine combination therapy, with nearest neighbour matching for the time of the baseline episode and the number of previously recorded vivax episodes.

```{r falcip_mononinf}

falcip_monoinf <- malaria_consultations_reconciled %>%
  mutate(WINDOW=RelativeTime%/%TIME_STEP+1) %>%
  subset(VIVAX==0 & FALCIP==1 & Treatment %in% c("AS", "AS+MF") & WINDOW<N_OBS-max(POST_WINDOWS)-1 & 
           !near_treatment_failure) %>% 
  transmute(VIN=as.character(VIN), WINDOW=RelativeTime%/%TIME_STEP+1,
            Treatment=Treatment, PfTime=RelativeTime, 
            Group=as.numeric(Treatment=="AS"))

falcip_monoinf$Prev_Pv_ep <- apply(falcip_monoinf, 1, function(x) 
  malaria_consultations_reconciled %>% 
    subset(as.character(VIN)==as.character(x[["VIN"]]) & VIVAX==1 & 
             RelativeTime<as.numeric(x[["PfTime"]])) %>% nrow)

falcip_monoinf$Next_Pv_ep <- apply(falcip_monoinf, 1, function(x) {
  Pv_after_baseline <- malaria_consultations_reconciled %>%
    subset(as.character(VIN)==as.character(x[["VIN"]]) & VIVAX==1 & 
             RelativeTime>as.numeric(x[["PfTime"]]))
  if (nrow(Pv_after_baseline)==0) return(Inf)
  return(min(Pv_after_baseline$RelativeTime)%/%TIME_STEP+1)})
  
match_falcip_monoinf_covariates <- 
  matchit(Group ~ Prev_Pv_ep + PfTime, data=falcip_monoinf,
          distance="glm", method="nearest")

falcip_monoinf <- 
  match.data(match_falcip_monoinf_covariates, drop.unmatched = FALSE)

falcip_monoinf_groups <- list()

falcip_monoinf_groups[["AS"]] <- which(falcip_monoinf$Treatment=="AS")
falcip_monoinf_groups[["AS+MF"]] <- which(falcip_monoinf$Treatment=="AS+MF")
falcip_monoinf_groups[["AS+MF matched"]] <- 
  which(falcip_monoinf$Treatment=="AS+MF" & falcip_monoinf$weights==1)

names(falcip_monoinf_groups) <- paste0(names(falcip_monoinf_groups), " (n=",
                                       sapply(falcip_monoinf_groups, length), ")")

```

```{r vivax_after_falcip}

vivax_recur_prob_windows <- lapply(POST_WINDOWS, function(W) {
  mapply(vivax_recur_prob_indiv, falcip_monoinf$VIN, falcip_monoinf$WINDOW, W)})
#write_rds(vivax_recur_prob_windows, "vivax_recur_prob_windows.rds")

prop_pv_after_pf <- function(Pf_monoinf_subset) {
  lapply(1:length(POST_WINDOWS), function(i) {
    
    POST_WINDOW <- POST_WINDOWS[i]
    
    # restrict attention to the subset of baseline episode with at least partial
    # clinical follow-up in the window of interest
    x <- vivax_recur_prob_windows[[i]][,Pf_monoinf_subset]
    x <- x[,colMeans(apply(x, 2, is.na))<1]

    if (length(x)==0) {
      return(data.frame(Prop_Pv=NA, CDF=NA))
    }
    
    if (is.null(dim(x))) {
      return(data.frame(Prop_Pv=NA, CDF=NA))
    }

    N_Pv <- sum(falcip_monoinf[Pf_monoinf_subset,]$Next_Pv_ep-
                       falcip_monoinf[Pf_monoinf_subset,]$WINDOW <= POST_WINDOW)
    
    Pv_prop_vals <- seq(0, 1, 1/ncol(x))
      
    Pv_prop_cdf <- apply(x, 1, function(pp) {
      pp <- subset(pp, pp>0 & pp<1)
      return(poisbinom::ppoisbinom(length(pp)*Pv_prop_vals, pp))})
    
    Pv_prop_summary <- data.frame(Prop_Pv=Pv_prop_vals, CDF=rowMeans(Pv_prop_cdf),
                                  POST_WINDOW=POST_WINDOW, observed=FALSE)
    Pv_prop_summary[N_Pv+1, "observed"] <- TRUE
    
    return(Pv_prop_summary)}) %>% bind_rows()
}

prop_pv_after_pf_pred <- lapply(falcip_monoinf_groups, prop_pv_after_pf)

prop_pv_after_pf_CrI <- lapply(prop_pv_after_pf_pred, function(x) {
  x %>% split(f=.$POST_WINDOW) %>% 
    lapply(function(x) c(POST_WINDOW=x[1, "POST_WINDOW"], 
                         LCI=min(subset(x$Prop_Pv, x$CDF>=0.005)), 
                         UCI=min(subset(x$Prop_Pv, x$CDF>=0.995)), 
                         observed=subset(x$Prop_Pv, x$observed)[1], 
                         pvalue=subset(x$CDF, x$observed)[1])) %>% bind_rows()
  }) %>% bind_rows(.id="Group")

```


```{r vivax_after_falcip_plot, echo=FALSE, fig.height=3.5, fig.width=7}

prop_pv_after_pf_CrI %>%
  mutate(pvalue=scales::scientific(1-pvalue, digits=4)) %>%
  kable %>% kableExtra::kable_styling(full_width = FALSE)

Pv_after_Pf_plot <- 
  ggplot(prop_pv_after_pf_CrI, aes(x=POST_WINDOW*TIME_STEP, color=Group, fill=Group)) +
  geom_point(aes(y=observed), size=2.5, pch=21, position=position_dodge(width=5), color="black") +
  geom_errorbar(aes(ymin=LCI, ymax=UCI, width=ifelse(POST_WINDOW<=3, 2, 6)),
                position=position_dodge(width=5)) +
  scale_x_continuous(breaks=TIME_STEP*POST_WINDOWS) +
  xlab("Follow-up window (days)") +
  ylab("Proportion of falciparum monoinfections\nfollowed by vivax infection") +
  ggtitle("Vivax malaria after falciparum monoinfection") +
  theme_bw() + theme(plot.title = element_text(face="bold", hjust=0.5),
                      legend.position = "bottom", legend.text = element_text(size=10))

show(Pv_after_Pf_plot)

pdf("Metrics_of_interest/vivax_after_falcip.pdf", height=4.2, width=6.5)
show(Pv_after_Pf_plot)
invisible(dev.off())

```


## Metrics of epidemiological interest

We now derive metrics of epidemiological interest, predicated on our posterior median estimates.

```{r param_labels, echo=FALSE}
COARSE_LAMBDA_VALS <- seq(0.25, 2, 0.25)/365
FINE_LAMBDA_VALS <- seq(0.01, 2, 0.01)/365

param_label <- bquote(atop(nu ~ p[rel] ~ "=" ~ .(round(NU_POSTERIOR*PREL_BASELINE, 1)) ~ "hypnozoites per bite",
                           eta ~ "=" ~ "1/" * .(round(1/ETA_POSTERIOR, 0)) ~ "per day"))

param_label_2 <- bquote(atop(nu ~ "=" ~ .(round(NU_POSTERIOR, 1)) ~ "sporozoites per bite",
                             p[rel] ~ "=" ~ .(PREL_BASELINE) ~ ", " ~ eta ~ "=" ~ "1/" * .(round(1/ETA_POSTERIOR, 0)) ~ "per day"))
```

### Overdispersion and zero-inflation of the hypnozoite reservoir

Here, we consider the size of the hypnozoite reservoir, and the time to spontaneous clearance of the hypnozoite reservoir (with a threshold probability) assuming mosquito-to-human transmission is temporarily interrupted (e.g. due to widespread administration of ivermectin).

**Assumption**: hypnozoite reservoir has reached stationarity under a constant force of inoculation.

```{r overdispersed_hyp}
# Size of the hypnozoite reservoir at stationarity
HMAX <- 11
TIMES <- seq(0, 730, 0.05)
hyp_tail_dist <- sapply(COARSE_LAMBDA_VALS, function(x) {
  hyp_reservoir_stationary_cdf(HMAX, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, x)}) %>% 
  as.data.frame %>% mutate(n_hyp=0:HMAX) %>% reshape2::melt(id="n_hyp") %>% 
  transmute(n_hyp=n_hyp+1, tail_prob=1-value,
            lambda=COARSE_LAMBDA_VALS[as.numeric(gsub("V", "", variable))]*365) 

# Time to spontaneous clearance of the hypnozoite reservoir
# (assuming mosquito-to-human transmission temporarily interrupted)
THRESHOLD_VALS <- c(0.8, 0.85, 0.9, 0.95, 0.96, 0.97, 0.98, 0.99)
clearance_time <- lapply(THRESHOLD_VALS, function(THRESHOLD) 
  data.frame(LAMBDA=FINE_LAMBDA_VALS*365, THRESHOLD=THRESHOLD, 
             Clearance_Prob_Time=sapply(FINE_LAMBDA_VALS, function(x) 
               time_to_clear_hyp(THRESHOLD, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, x)))) %>% 
  bind_rows()
```

At a force of inoculation of 0.5 bites per year, only `r round(100*(1-hyp_reservoir_stationary_pmf(0, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, 0.5/365)))`% of people are predicted to carry hypnozoites; however, to ensure spontaneous hypnozoite clearance with probability 0.98, mosquito-to-human transmission would need to be interrupted for `r round(time_to_clear_hyp(0.98, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, 0.5/365), 1)` years.
`
```{r overdispersed_hyp_plot, fig.height=4.25, fig.width=12, echo=FALSE, out.width="100%"}
hyp_tail_dist_plot <- 
  ggplot(hyp_tail_dist, aes(x=n_hyp, y=tail_prob, group=lambda, color=lambda)) + 
  geom_line() + geom_point() + 
  annotate("text", x=9, y=0.6, label=param_label, size=3.5) +
  scale_x_continuous(breaks=1:HMAX) +
  scale_color_viridis_c(breaks=seq(0.25, 2, 0.25), limits=c(0, 2), name = "FOI\n(per year)") + 
  xlab("Hypnozoite burden") + 
  ylab("Tail distribution\nProb(>= n hypnozoites)") + 
  ggtitle("Predicted steady state hypnozoite burden") +
  labs(subtitle="Individuals >4 years in a constant transmission setting") +
  theme_light() + theme(plot.title = element_text(face="bold", hjust=0.5),
                        plot.subtitle = element_text(hjust=0.5),
                        legend.title = element_text(hjust=0.5),
                        legend.key.height = unit(0.45, "in"))

clearance_time_plot <- 
  ggplot(clearance_time, aes(x=LAMBDA, y=Clearance_Prob_Time, group=THRESHOLD, color=THRESHOLD)) + 
  geom_line() +
  annotate("text", x=1.375, y=0.2, label=param_label, size=3.5) +
  #annotate("text", x=0.55, y=2.325, label=param_label, size=3) +
  xlab("Prior force of inoculation (per year)") +
  ylab("Time for which mosquito-to-human\ntransmission must be interrupted (years)") +
  ggtitle("Time to spontaneous hypnozoite clearance with\ninterrupted mosquito-to-human transmission") +
  scale_color_viridis_c(breaks=THRESHOLD_VALS, option="plasma", limits=c(0.8, 1), #trans="logit",
                        name="Threshold\nproportion of\nindividuals\ncarrying no\nhypnozoites") +
  theme_light() + theme(plot.title = element_text(face="bold", hjust=0.5),
                        legend.title = element_text(hjust=0.5),
                        legend.key.height = unit(0.45, "in"))

overdispersed_hyp_plot <- 
  cowplot::plot_grid(hyp_tail_dist_plot, clearance_time_plot, nrow=1, 
                     align="vh", axis="tblr", labels=c("(A)", "(B)"))

show(overdispersed_hyp_plot)

pdf("Metrics_of_interest/overdispersed_hypnozoite_reservoir.pdf", height=4.25, width=12)
show(overdispersed_hyp_plot)
invisible(dev.off())

```

### Recent recurrence as a predictor of hypnozoite carriage

Here, we consider the predictive value of recent bloodstream infection as a predictor of hypnozoite carriage.

**Assumption**: hypnozoite reservoir has reached stationarity under a constant force of inoculation.

```{r recent_recur_hyp_predictor}
SEROTAT_WINDOW <- 270

sensitivity_specificity_recent_recur <- sapply(FINE_LAMBDA_VALS, function(LAMBDA) 
  recent_recur_accuracy_stationary(SEROTAT_WINDOW, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, LAMBDA)) %>% 
  t %>% as.data.frame %>% 
  transmute(LAMBDA=FINE_LAMBDA_VALS*365, Hyp_Carriage=Hyp_Carriage,
            Recent_Recur=Sensitivity*Hyp_Carriage/Recent_Recurrence,
            No_Recent_Recur=1-Specificity*(1-Hyp_Carriage)/(1-Recent_Recurrence)) %>%
  reshape2::melt(id="LAMBDA")
```

```{r recent_recur_hyp_predictor_report_vals, echo=FALSE}
a1 <- recent_recur_accuracy_stationary(270, ETA_POSTERIOR,
                                 NU_POSTERIOR, PREL_BASELINE, 0.5/365)
a2 <- recent_recur_accuracy_stationary(270, ETA_POSTERIOR,
                                 NU_POSTERIOR, PREL_BASELINE, 2/365)
```

At a force of inoculation of 0.5 infectious bites per year, individuals who have had recent recurrences are `r round(a1[["Sensitivity"]]/a1[["Recent_Recurrence"]], 1)` as likely to harbour hypnozoites than randomly-sampled individuals; for 2 bites year, they are only `r round(a2[["Sensitivity"]]/a2[["Recent_Recurrence"]], 1)` times more likely to harbour hypnozoites. The false omission rate (conditional probability of hypnozoite carriage given no recent recurrences) is generally low but rises to `r round(100*(1-a2[["Specificity"]]*(1-a2[["Hyp_Carriage"]])/(1-a2[["Recent_Recurrence"]])))`% under a force of inoculation of 2 infectious bites per year.

```{r recent_recur_hyp_predictor_plot, echo=FALSE, fig.height=5.5, fig.width=6, out.width="50%"}
recent_recur_plot <- ggplot(sensitivity_specificity_recent_recur) + 
  geom_line(aes(x=LAMBDA, y=value, color=variable, lty=variable), lwd=0.75) +
  annotate("text", x=0.4, y=0.675, label=param_label_2, size=3.6) +
  scale_color_manual(values=c("#4f4f4f", "darkgreen", "#996262"), name="",
                     labels=c("Randomly-sampled individual",
                              "Conditional on bloodstream infection within 9 months",
                              "Conditional on no bloodstream infections within 9 months")) +
  scale_linetype_manual(values=c(2, 1, 1), name="",
                        labels=c("Randomly-sampled individual",
                                 "Conditional on bloodstream infection within 9 months",
                                 "Conditional on no bloodstream infections within 9 months")) +
  xlab("Force of inoculation (per year)") +
  ylab("Probability of hypnozoite carriage") +
  ggtitle("Bloodstream infection within 9 months as a\npredictor of hypnozoite carriage") +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, face="bold"),
                     legend.text = element_text(size=10.5),
                     legend.position = "bottom",
                     legend.direction = "vertical",
                     legend.key.width = unit(0.5, "in"))

show(recent_recur_plot)

pdf("Metrics_of_interest/recent_recur_hyp_predictor.pdf", height=5.5, width=6)
show(recent_recur_plot)
invisible(dev.off())
```


### Theoretical comparison of MSAT vs MDA

Here, we perform a theoretical comparison of MSAT vs MDA, whilst accommodating population heterogeneity in the form of a Gamma-distributed force of inoculation (Smith et al, 2005).

**Assumptions**: for each individual, the hypnozoite reservoir has reached stationarity under a force of inoculation sampled from a uniform distribution; the outcome of the serological test given recent recurrence is conditionally independent to hypnozoite carriage.

**Note**: the expression for the proportion of hypnozoite carriers who are correctly-targeted is formulated in terms of the Hurwitz-Zeta function; we have computed this expression using Mathematica, since there is no available implementation in R. 

```{r msat_vs_mda}
SEROTAT_WINDOW <- 270
SEROTAT_SPEC <- 0.8
SEROTAT_SENS <- 0.8
THETA_VALS <- 10^seq(-7, 0, 0.01)

serotat_specificity_het <- 
  lapply(COARSE_LAMBDA_VALS, function(LAMBDA_MEAN) {
    data.frame(THETA=THETA_VALS, LAMBDA=LAMBDA_MEAN*365, 
               Specificity=sapply(THETA_VALS, function(THETA) {
                 recent_recur_specificity_stationary_het(SEROTAT_WINDOW, ETA_POSTERIOR, NU_POSTERIOR,
                                                         PREL_BASELINE, LAMBDA_MEAN, THETA)}))}) %>% 
  bind_rows() %>% mutate(PROP_TOP_20=prop_bites_top_20(THETA, LAMBDA/365),
                         GINI_COEFF=acid::gini.gamma(THETA))

# Hurwitz-zeta function (with shift!=1) not implemented in R, sensitivity
# in the presence of heterogeneity computed in Mathematica; numerical overflow
# and loss of precision if theta too small
param_vals <- expand.grid(SEROTAT_WINDOW=SEROTAT_WINDOW, ETA=ETA_POSTERIOR, NU=NU_POSTERIOR,
                          PREL=PREL_BASELINE, LAMBDA=COARSE_LAMBDA_VALS, THETA=THETA_VALS) %>%
  subset(THETA>=10^-4)

write.csv(param_vals, file="Metrics_of_interest_code/recent_recur_sensitivity_stationary_het_params.csv", row.names = FALSE)

recent_recur_sensitivity_het <- 
  read.delim("Metrics_of_interest_code/recent_recur_sensitivity_stationary_het_Mathematica.dat", header=FALSE)
  
serotat_sensitivity_het <- 
  bind_cols(param_vals[, c("LAMBDA", "THETA")], recent_recur_sensitivity_het) %>%
  transmute(PROP_TOP_20=prop_bites_top_20(THETA, LAMBDA), LAMBDA=LAMBDA*365, Sensitivity=V1)

serotat_sensitivity <- 
  data.frame(LAMBDA=COARSE_LAMBDA_VALS*365, PROP_TOP_20=0.2,
             Sensitivity=sapply(COARSE_LAMBDA_VALS, function(x) 
               recent_recur_accuracy_stationary(SEROTAT_WINDOW, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, x)[["Sensitivity"]]))

serotat_sensitivity_het <- bind_rows(serotat_sensitivity_het, serotat_sensitivity)
  
```

In a population where individuals are bitten once a year on average, but 20% of individuals receive 80% of all infective bites (Gini coefficient `r round(acid::gini.gamma(0.01122018), 3)`), we predict serological MSAT to yield a `r round(1/(SEROTAT_SPEC-(SEROTAT_SPEC+SEROTAT_SENS-1)*recent_recur_specificity_stationary_het(SEROTAT_WINDOW, ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE, 1/365, 0.01122018)), 1)` fold reduction in overtreatment relative to MDA (in the eligible population).

```{r msat_vs_mda_plots, echo=FALSE, fig.height=5, fig.width=11.5, out.width="100%"}
serotat_het_plots <- list()

serotat_het_plots[["sensitivity"]] <- serotat_sensitivity_het %>% 
  subset(PROP_TOP_20<=0.99) %>%
  ggplot(aes(x=PROP_TOP_20, y=1-SEROTAT_SPEC+(SEROTAT_SENS+SEROTAT_SPEC-1)*Sensitivity, 
             group=LAMBDA, color=LAMBDA)) + 
  geom_line() +
  geom_hline(aes(yintercept=1), lty=2, col="black", lwd=0.6) +
  annotate("text", x=0.785, y=0.1, label=param_label_2, size=3.3) +
  scale_color_viridis_c(breaks=seq(0.25, 2, 0.25), limits=c(0, 2), name = "Mean\nFOI\n(per year)") + 
  scale_x_continuous(limits=c(0.2, 0.99), expand=c(0,0), breaks=c(0.2, 0.4, 0.6, 0.8, 0.99)) + 
  scale_y_continuous(limits=c(0, 1)) +
  xlab("Proportion of bites experienced by the 20% of individuals\nsubject to the highest transmission intensity") +
  ggtitle("Proportion of eligible hypnozoite carriers correctly-treated") +
  ylab("P(positive test | hypnozoites)") +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, size=12.5),
                     axis.title = element_text(size=11.5),
                     legend.title = element_text(hjust=0.5),
                     legend.key.height = unit(0.45, "in"))

serotat_het_plots[["overtreatment"]] <- serotat_specificity_het %>%
  subset(PROP_TOP_20<=0.99) %>%
  ggplot(aes(x=PROP_TOP_20, y=1/(SEROTAT_SPEC-(SEROTAT_SPEC+SEROTAT_SENS-1)*Specificity), 
             group=LAMBDA, color=LAMBDA)) + 
  geom_line() +
  geom_hline(aes(yintercept=1), lty=2, col="black", lwd=0.6) +
  annotate("text", x=0.785, y=1.3, label=param_label_2, size=3.3) +
  scale_color_viridis_c(breaks=seq(0.25, 2, 0.25), limits=c(0, 2), name = "Mean\nFOI\n(per year)") + 
  scale_x_continuous(limits=c(0.2, 0.99), expand=c(0,0), breaks=c(0.2, 0.4, 0.6, 0.8, 0.99)) + 
  xlab("Proportion of bites experienced by the 20% of individuals\nsubject to the highest transmission intensity") +
  ggtitle("Fold reduction in overtreatment for MSAT relative to MDA") +
  ylab("1/P(positive test | no hypnozoites)") +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, size=12.5),
                     axis.title = element_text(size=11.5),
                     legend.title = element_text(hjust=0.5),
                     legend.key.height = unit(0.45, "in"))

fori_legend <- get_legend(serotat_het_plots[[1]])

serotat_het_plot_grid <- 
  plot_grid(serotat_het_plots[[1]] + theme(legend.position = "none"), 
            serotat_het_plots[[2]] + theme(legend.position = "none"), 
            ggdraw(fori_legend), nrow=1, rel_widths=c(1, 1, 0.2), 
            labels=c("(A)", "(B)", ""))

serotat_title <- ggdraw() + 
  draw_label(paste0("Impact of serological MSAT relative to MDA\n(", 
                    SEROTAT_SPEC*100, "% specificity, ", 
                    SEROTAT_SENS*100, "% sensitivity for bloodstream infection within 9 months)"),
             fontface = 'bold', x = 0.5, hjust = 0.5) +
  theme(plot.margin = margin(0, 0, 0, 7))

serotat_plot <- plot_grid(serotat_title, serotat_het_plot_grid, ncol=1, rel_heights = c(0.15, 1))

show(serotat_plot)

pdf("Metrics_of_interest/serotreat_impact_pop_het.pdf", height=5, width=11.5)
show(serotat_plot)
invisible(dev.off())
```


### Consecutive recurrences derived from the same sporozoite batch

Here, we assume that an individual has a baseline recurrence on day 1 and consider both the time to the secondary recurrence, and the probability that the baseline and secondary recurrences are derived from different sporozoite batches.

**Assumption**: hypnozoite reservoir has reached stationarity under a constant force of inoculation.

```{r batch_identity}
# discretised in time steps of days
N_VALS <- 2:250
baseline_to_secondary_recurrence <- 
  lapply(COARSE_LAMBDA_VALS, function(LAMBDA) {
     data.frame(LAMBDA=LAMBDA*365, time=c(0, N_VALS-1),
               cdf_next_recur=cumsum(c(0, conditional_prob_next_recurrence(N_VALS, 1, LAMBDA, 
                                            NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR))),
               prob_same_batch=c(NA, conditional_prob_same_batch(N_VALS, 1, LAMBDA, 
                                  NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR)))}) %>% bind_rows
```

Under a force of inoculation of 0.5 bites per year, we predict `r round(100*sum(conditional_prob_next_recurrence(n=2:29, TIME_STEP=1, LAMBDA=0.5/365, NU=NU_POSTERIOR, PREL=PREL_BASELINE, ETA=ETA_POSTERIOR)))`% of baseline recurrences to be followed by a second recurrence within 28 days of follow-up, with this figure rising to `r round(100*sum(conditional_prob_next_recurrence(n=2:29, TIME_STEP=1, LAMBDA=2/365, NU=NU_POSTERIOR, PREL=PREL_BASELINE, ETA=ETA_POSTERIOR)))`% under a more intense force of inoculation of 2 bites per year.

Given a secondary recurrence occurs precisely 28 days after a baseline recurrence, we preiduct that it is derived from a different sporozoite batch with probability `r round(1-conditional_prob_same_batch(n=29, TIME_STEP=1, LAMBDA=0.5/365, NU=NU_POSTERIOR, PREL=PREL_BASELINE, ETA=ETA_POSTERIOR), 2)` under a force of inoculation of 0.5 bites per year, but a substantially higher probability of `r round(1-conditional_prob_same_batch(n=29, TIME_STEP=1, LAMBDA=2/365, NU=NU_POSTERIOR, PREL=PREL_BASELINE, ETA=ETA_POSTERIOR), 2)` under a force of inoculation of 2 bites per year.

```{r batch_identity_plots, echo=FALSE, fig.height=4.5, fig.width=12}
baseline_to_secondary_time_plot <- 
  ggplot(baseline_to_secondary_recurrence) + 
  geom_line(aes(x=time, y=cdf_next_recur, color=LAMBDA, group=LAMBDA)) + 
  coord_cartesian(ylim=c(0, 1)) + 
  viridis::scale_colour_viridis(breaks=COARSE_LAMBDA_VALS*365, name="FOI\n(per year)  ") + 
  ggtitle("Time between successive recurrences") +
  labs(subtitle = "Assuming a stationary hypnozoite reservoir and no prophylaxis") + 
  xlab("Time since baseline recurrence (days)") +
  ylab("Probability of secondary recurrence") +
  theme_bw() + theme(legend.position = "none",
                     plot.title = element_text(hjust=0.5, face="bold"),
                     plot.subtitle = element_text(hjust=0.5))

baseline_secondary_same_batch_plot <- 
  ggplot(baseline_to_secondary_recurrence) +
  geom_line(aes(x=time, y=1-prob_same_batch, color=LAMBDA, group=LAMBDA)) + 
  coord_cartesian(ylim=c(0, 1)) + 
  viridis::scale_colour_viridis(breaks=COARSE_LAMBDA_VALS*365, name="FOI\n(per year)  ") + 
  ggtitle("Probability that successive recurrences\nare derived from different sporozoite batches") +
  labs(subtitle = "Assuming a stationary hypnozoite reservoir and no prophylaxis") + 
  xlab("Inter-recurrence interval (days)") +
  ylab("Probability that successive recurrences\nare derived from different sporozoite batches") +
  theme_bw() + theme(legend.key.width = unit(0.9, "inches"),
                     legend.position = "bottom",
                     plot.title = element_text(hjust=0.5, face="bold"),
                     plot.subtitle = element_text(hjust=0.5))

legend <- cowplot::get_legend(baseline_secondary_same_batch_plot)

baseline_secondary_recurrence_plot <- 
  plot_grid(plot_grid(baseline_to_secondary_time_plot, 
                         baseline_secondary_same_batch_plot + theme(legend.position = "none"), 
                         labels=c("(A)", "(B)"), nrow=1, align="vh", axis="tblr"),
               legend, ncol=1, rel_heights = c(6, 1))

show(baseline_secondary_recurrence_plot)

pdf("Metrics_of_interest/recurrence_batch_identity.pdf",width=12, height=5)
show(baseline_secondary_recurrence_plot)
invisible(dev.off())

```

### Background recurrence rate

Granular analysis of the risk of vivax malaria following symptomatic falciparum malaria is confounded by seasonality. As a baseline compartor, we derive the force of inoculation required to yield spontaneous recurrence with a given probability in any defined window of follow-up, accounting for antidisease masking (but without adjusting for post-exposure prophylaxis). 

Ignoring the effects of seasonality and post-exposure prophylaxis, we can derive the force of inoculation required to yield recurrence with a given probability over a period of clinical follow-up.

**Assumption**: hypnozoite reservoir has reached stationarity under a constant force of inoculation.

```{r background_recurrence}
background_recurrence <- 
  expand.grid(W=c(30, 60, 90), p_recur=seq(0, 0.5, 0.01), PCLIN=seq(0.5, 1, 0.1)) %>%
  mutate(FORI=fori_required_for_recur(W, p_recur, NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, PCLIN)*365,
         W=paste0(W, " days of follow-up"))
```

To ensure spontaneous recurrence with probability 0.14 over 60 days of follow-up, an average of `r fori_required_for_recur(60, 0.14, NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, 1)*365` bites per year would be required; adjusting for antidisease masking, with each hypnozoite activation and immediate sporozoite development event giving rise to clinical symptoms with probability 0.75, this this figure rises to an average of `r fori_required_for_recur(60, 0.14, NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, 0.75)*365` bites per year. To explain the corresponding proportion of 0.42 over 60 days of follow-up after rapidly-eliminated antimalarial treatment, we would instead require `r fori_required_for_recur(60, 0.42, NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, 1)*365` bites per year (ignoring antidisease masking) or `r fori_required_for_recur(60, 0.42, NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, 0.75)*365` bites per year in the setting where each hypnozoite activation and immediate sporozoite development event giving rise to clinical symptoms with probability 0.75.

```{r background_recurrence_plot, echo=FALSE, fig.height=3.5, fig.width=12}
background_recurrence_plot <- ggplot(background_recurrence) +
  geom_line(aes(x=p_recur, y=FORI, group=PCLIN, color=PCLIN)) + 
  facet_wrap(vars(W), nrow=1) +
  xlab("Probability of recurrence in follow-up period") +
  ylab("Force of inoculation (per year)") +
  ggtitle("Probability of recurrence during follow-up") +
  labs(subtitle="At stationarity under a constant force of inoculation") +
  coord_cartesian(ylim=c(0, 3)) +
  scale_color_viridis_c(name="Probability of\nsymptomatic\ninfection", option="cividis") +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, face="bold"),
                     plot.subtitle = element_text(hjust=0.5))

show(background_recurrence_plot)

pdf("Metrics_of_interest/background_recurrence_rate.pdf", height=3, width=9)
show(background_recurrence_plot)
invisible(dev.off())

```

### Relapse burden per bite
Here, we consider the inter-relapse times following a single infective bite (with a geometrically-distributed hypnozoite inoculum), with the assumption that a hypnozoite activation event gives rise to a detectable relapse if and only if it occurs at least T_MASK days after the previous detectable relapse.

```{r detectable_relapses}
T_MASK <- 10
relapses_per_bite <- detectable_relapses_per_bite(NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, T_MASK)
inter_relapse_cdf_per_bite <- inter_relapse_cdfs(NU_POSTERIOR, PREL_BASELINE, ETA_POSTERIOR, T_MASK, seq(0, 300, 2))
```

```{r detectable_relapses_plot, fig.width=8, fig.height=10, out.width="70%", echo=FALSE}
relapses_per_bite %>% kable %>% kable_styling(full_width = F) %>% scroll_box(height="150px")
relapses_per_bite_plot <- relapses_per_bite %>% reshape2::melt(id="n_relapses") %>% 
  mutate(variable=ifelse(variable=="detected", 
                         paste0("detectable relapses (i.e. separated by >=", T_MASK, " days)"),
                         "hypnozoite activation events")) %>%
  ggplot(aes(x=n_relapses, y=value, group=variable, lty=variable)) + 
  geom_line(alpha=0.5) + geom_point(aes(fill=variable), color="black", size=2.5, shape=21) + 
  scale_x_continuous(breaks=1:16) +
  scale_fill_manual(name=NULL, values=c("#edaa95", "#a83816")) + 
  scale_linetype_manual(name=NULL, values=c(2, 1)) +
  xlab("n") + ylab("Proportion with >=n relapses") + 
  ggtitle("Number of relapses per infective bite") +
  guides(fill = guide_legend(nrow = 2)) +
  labs(subtitle=paste0("Adjusted for masking (", T_MASK, " day windows)")) +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, face="bold"),
                     plot.subtitle = element_text(hjust=0.5),
                     strip.text = element_text(face="bold", size=10),
                     legend.position = "bottom",
                     legend.text = element_text(size=9.5))

inter_relapse_cdf_plot <- ggplot(inter_relapse_cdf_per_bite) + 
  #annotate("rect", xmin=4, xmax=6, ymin=-Inf, ymax=Inf, fill="black", alpha=0.2) +
  geom_line(aes(x=time/7, y=1-value, group=variable, color=variable)) + 
  facet_wrap(vars(n_detected)) + 
  xlab("Inter-relapse time (weeks)") + ylab("Cumulative distribution function") + 
  ggtitle("Inter-relapse intervals for a single infective bite") +
  labs(subtitle=paste0("Adjusted for masking (", T_MASK, " day windows)")) +
  scale_color_discrete(labels=c("bite to 1st relapse", "1st to 2nd relapse", 
                                "2nd to 3rd relapse", "3rd to 4th relapse", 
                                "4th to 5th relapse", "5th to 6th relapse", 
                                "6th to 7th relapse", "7th to 8th relapse"), 
                       name="Interval") +
  guides(color = guide_legend(nrow = 2)) +
  theme_bw() + theme(plot.title = element_text(hjust=0.5, face="bold"),
                     plot.subtitle = element_text(hjust=0.5),
                     strip.text = element_text(face="bold", size=10),
                     legend.position = "bottom",
                     legend.text = element_text(size=9.5))

relapses_single_bite_plot <- 
  plot_grid(plot_grid(NULL, relapses_per_bite_plot, NULL, nrow=1, 
                         rel_widths=c(0.5, 2, 0.5), labels=c("", "(A)", "")), 
               inter_relapse_cdf_plot, ncol=1, labels=c("", "(B)"),  
               rel_heights=c(1, 1.5), scale=0.95)

show(relapses_single_bite_plot)

pdf("Metrics_of_interest//relapses_per_bite.pdf", height=10, width=8.5)
show(relapses_single_bite_plot)
invisible(dev.off())

```

Ignoring any masking of hypnozoite activation events in quick succession, we also calculate the coefficient of variation (CV) for the mth inter-relapse times following a single infective bite. We can show that the CV is independent of m.
```{r cv_interrelape_time_cv}
CV <- sapply(MCMC_posterior$NU, 
             function(NU) sqrt(2*NU*PREL_BASELINE*HMMcopula::dilog(1/(1+NU*PREL_BASELINE)) -
                                 log(1+NU*PREL_BASELINE)^2)/log(1+NU*PREL_BASELINE))
```
We estimate this CV to be `r round(median(CV), 2)` (95% CrI `r round(quantile(CV, 0.025), 2)` to `r round(quantile(CV, 0.975), 2)`).

### Probabilistic classification of relapse vs primary infection

Here, we derive the probability that each recorded clinical recurrence is a relapse (defined to be the probability that it is caused by hypnozoite activation event(s) only). In deriving this probability, we account for the effects of prophylactic bunching, and condition on **all** observed inter-recurrence intervals, both before and after the target episode. Unlike other metrics, this classification additionally relies on posterior estimates for the force of inoculation (including seasonality) and the age-dependent probability of symptomatic infection.

```{r classify_relapse}
PCLIN_VALS <- PCLIN_POSTERIOR[as.character(N_AGES/YEAR_IN_TIMESTEP)]
names(PCLIN_VALS) <- names(N_AGES)

relapse_classfication <- 
  classify_relapses(inf_states_by_VIN, N_AGES, PCLIN_VALS, FORI_POSTERIOR, 
                    ETA_POSTERIOR, NU_POSTERIOR, PREL_BASELINE)
```

We visualise probabilistic classifications for all 7 year olds with at least two recorded recurrences below. Crosses indicate recorded falciparum infections; light grey bars indicate masking (due to left- or right-censoring, a documented absence from the camp or post-exposure prophylaxis); and dark grey boxes indicate recurrences which could not be probabilistically classified due to numerical errors.

```{r classify_relapse_plot, fig.width=10, fig.height=5, echo=FALSE}
masking_windows <- 
  lapply(inf_states_by_VIN, function(x) data.frame(MASKED=which(x=="M"))) %>%
  bind_rows(.id="VIN")

VIN_with_recurrence <- names(Filter(function(x) sum(x %in% c("C", "B"))>1, inf_states_by_VIN))

keep_VIN_7yo <- intersect(VIN_with_recurrence, subset(patient_metadata$VIN, patient_metadata$AGE==7))
keep_VIN_7yo_order <- (relapse_classfication %>% subset(VIN %in% keep_VIN_7yo) %>% 
                         group_by(VIN) %>% summarise(count=n()) %>% arrange(-count))$VIN

masking_windows_keep_VIN <- 
  lapply(inf_states_by_VIN, function(x) data.frame(MASKED=which(x=="M"))) %>%
  bind_rows(.id="VIN") %>% subset(as.character(VIN) %in% keep_VIN_7yo) %>%
  mutate(VIN=factor(as.character(VIN), levels=keep_VIN_7yo_order))

relapse_classification_keep_VIN <- relapse_classfication %>% 
  subset(as.character(VIN) %in% keep_VIN_7yo) %>%
  mutate(VIN=factor(VIN, levels=keep_VIN_7yo_order))

falciparum_keep_VIN <- malaria_consultations_reconciled %>%
  subset(FALCIP==1 & as.character(VIN) %in% keep_VIN_7yo) %>%
  mutate(VIN=factor(VIN, levels=keep_VIN_7yo_order),
         RelativeTime=TIME_STEP*(RelativeTime%/%TIME_STEP)+TIME_STEP/2)

relapse_classification_plot <- ggplot() +
  geom_segment(aes(y=keep_VIN_7yo, yend=keep_VIN_7yo, x=0, xend=N_OBS*TIME_STEP), lwd=0.25) +
  geom_segment(data=masking_windows_keep_VIN, 
               aes(y=VIN, yend=VIN, x=(MASKED-1)*TIME_STEP, xend=MASKED*TIME_STEP), 
               lwd=1.1, col="darkgrey") +
  geom_segment(data=relapse_classification_keep_VIN, 
               aes(y=VIN, yend=VIN, x=(WINDOW-1)*TIME_STEP, xend=WINDOW*TIME_STEP, 
                   color=PROB_RELAPSE), lwd=2) +
  geom_point(data=falciparum_keep_VIN, aes(y=VIN, x=RelativeTime), pch=4) +
  xlab("Days from start of study") + ylab("Individuals") +
  labs(title="Probabilistic classification of symptomatic Pv episodes",
       subtitle=paste0("n=", length(keep_VIN_7yo),
                       " children, 7 years of age at enrolment (with at least 2 symptomatic Pv epsiodes)")) + 
  scale_x_continuous(expand=c(0, 0)) +
  scale_color_gradient(low="blue", high="darkorange", limits=c(0, 1), name="Pr(relapse)") +
  theme_light() + theme(axis.text.y = element_blank(),
                        plot.subtitle = element_text(hjust=0.5),
                        plot.title = element_text(face="bold", hjust=0.5))

show(relapse_classification_plot)

pdf("Metrics_of_interest/classify_relapse_primary_7yo.pdf",
    height=5.6, width=9)
show(relapse_classification_plot)
invisible(dev.off())
```
